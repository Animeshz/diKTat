Diktat does AST-analysis. This means that for internal representation (IR) it uses Abstract Syntax Tree that was created from the parsed code by the kotlin-compiler.  This chapter describes how diktat works

\subsection{ktlint}
\par
To quickly and efficiently analyze the program code, you first need to transform it into a convenient data structure. This is exactly what ktlint does - it parses plain text code into an abstract syntax tree. In ktlint, this happens in the \textsl{prepareCodeForLinting}\footnote{\url{https://github.com/pinterest/ktlint/blob/master/ktlint-core/src/main/kotlin/com/pinterest/ktlint/core/KtLint.kt}} method. This method uses Kotlin libraries to create a root node of type FILE.

\tikzstyle{every node}=[draw=black,thick,anchor=west, scale = 0.5]

\begin{tikzpicture}[%
  grow via three points={one child at (0.3,-0.8) and
  two children at (0.3,-0.8) and (0.3,-1.5)},
  scale=0.5,
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {FILE}
    child { node {PACKAGE\underline{ }DIRECTIVE}}
    child { node {IMPORT\underline{ }LIST}}
    child { node {FUN}
        child {node {fun}}
        child {node {WHITE\underline{ }SPACE}}
        child {node {IDENTIFIER}}
        child {node {VALUE\underline{ }PARAMETER\underline{ }LIST}
            child {node {LPAR}}
            child {node {RPAR}}
        }
        child [missing] {}				
        child [missing] {}
        child {node {WHITE\underline{ }SPACE}}
        child {node {BLOCK}
            child {node {LBRACE}}
            child {node {WHITE\underline{ }SPACE}}
            child {node {CALL\underline{ }EXPRESSION}
                child {node {REFERENCE\underline{ }EXPRESSION}
                    child {node {IDENTIFIER}}
                }
                child [missing] {}
                child {node {VALUE\underline{ }ARGUMENT\underline{}LIST}
                    child {node {LPAR}}
                    child {node {VALUE\underline{ }ARGUMENT}
                        child {node {STRING\underline{ }TEMPLATE}
                            child {node {OPEN\underline{ }QUOTE}}
                            child {node {LITERAL\underline{ }STRING\underline{ }TEMPLATE\underline{ }ENTRY}
                                child {node {REGULAR\underline{ }STRING\underline{ }PART}}
                            }
                            child [missing] {}
                            child {node {CLOSING\underline{ }QUOTE}}
                        }
                    }
                    child [missing] {}
                    child [missing] {}
                    child [missing] {}
                    child [missing] {}
                    child [missing] {}
                    child [missing] {}
                    child {node {RPAR}}
                }
            }
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child {node {WHITE\underline{ }SPACE}}
            child {node {RBRACE}}
        }
    };
\end{tikzpicture}

If there are error elements inside the constructed tree, then the corresponding error is displayed. Further, for each rule in the ruleset, the \textsl{visit} method is called to which the root node itself and its “children” are sequentially passed.
At startup, you can pass flags to ktlint - one of them is "-F". This flag means that the rule will not only report an error, but try to fix it.

\subsection{diKTat}
\par
Another feature of ktlint is that at startup you can transfer a JAR file with additional ruleset(s), and then all nodes will be passed to these rules. This is diKTat! DiKTat is a set of easily configurable rules for static code analysis. 
The set of all rules is described in the \textsl{DiktatRuleSetProvider}\footnote{\url{https://github.com/cqfn/diKTat/blob/master/diktat-rules/src/main/kotlin/org/cqfn/diktat/ruleset/rules/DiktatRuleSetProvider.kt}} class. This class overrides the \textsl{get()} method of the \textsl{RuleSetProvider}\footnote{\url{https://github.com/pinterest/ktlint/blob/master/ktlint-core/src/main/kotlin/com/pinterest/ktlint/core/RuleSetProvider.kt}} interface, which returns a set of rules to be "traversed". But before returning this set, the configuration file, in which the user has independently configured all the rules, is read. If there is no configuration file, then a warning will be displayed and the rules will be triggered in according with the default configuration file. 
Each rule must implement the \textsl{visit} method of the abstract Rule class, which describes the logic of the rule.

//TODO: add comments
\begin{lstlisting}[caption={Simple code listing.}, label={lst:example1}, language=Kotlin]
class SingleLineStatementsRule(private val configRules: List<RulesConfig>) : Rule("statement") {

    companion object {
        private val semicolonToken = TokenSet.create(SEMICOLON)
    }

    private lateinit var emitWarn: ((offset: Int, errorMessage: String, canBeAutoCorrected: Boolean) -> Unit)
    private var isFixMode: Boolean = false

    override fun visit(node: ASTNode,
                       autoCorrect: Boolean,
                       emit: (offset: Int, errorMessage: String, canBeAutoCorrected: Boolean) -> Unit) {
        emitWarn = emit
        isFixMode = autoCorrect

        checkSemicolon(node)
    }

    private fun checkSemicolon(node: ASTNode) {
        node.getChildren(semicolonToken).forEach {
            if (!it.isFollowedByNewline()) {
                MORE_THAN_ONE_STATEMENT_PER_LINE.warnAndFix(configRules, emitWarn, isFixMode, it.extractLineOfText(),
                        it.startOffset, it) {
                    if (it.treeParent.elementType == ENUM_ENTRY) {
                        node.treeParent.addChild(PsiWhiteSpaceImpl("\n"), node.treeNext)
                    } else {
                        if (!it.isBeginByNewline()) {
                            val nextNode = it.parent({ parent -> parent.treeNext != null }, strict = false)?.treeNext
                            node.appendNewlineMergingWhiteSpace(nextNode, it)
                        }
                        node.removeChild(it)
                    }
                }
            }
        }
    }
}
\end{lstlisting}

The example above describes the rule in which you cannot write more than two statements on one line. The list of configurations is passed to the parameter of this rule so that the error is displayed only when the rule is enabled (further it will be described how to enable and disable the rule). The class fields and the \textsl{visit} method are described below. The first parameter in method is ASTNode - the node that we got in the parsing in ktlint. Then a check occurs: if the code contains a line in which more than one statement per line and this rule is enabled, then the rule will be executed and, depending on the mode in which the user started ktlint, the rule will either simply report an error or fix it. In our case, when an error is found, the method is called to report and fix the error - \textsl{warnAndFix()}.

\subsection{Examples of unique inspections}
\par
